<!DOCTYPE html>
<html lang="zh-CN">
	<head>
		<meta charset="UTF-8" />
		<meta
			name="viewport"
			content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
		/>
		<title>GAuth è¿ç§»åŠ©æ‰‹ Pro (å…¨èƒ½ç‰ˆ)</title>
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link
			href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap"
			rel="stylesheet"
		/>
		<style>
			:root {
				--primary: #4f46e5;
				--primary-hover: #4338ca;
				--success: #10b981;
				--error: #ef4444;
				--bg-body: #f8fafc;
				--bg-surface: #ffffff;
				--text-main: #0f172a;
				--text-sub: #64748b;
				--border: #e2e8f0;
				--radius-lg: 16px;
				--radius-md: 12px;
				--shadow-sm: 0 1px 3px 0 rgb(0 0 0 / 0.1);
				--shadow-lg: 0 20px 25px -5px rgb(0 0 0 / 0.1);
			}
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}
			body {
				font-family: "Plus Jakarta Sans", sans-serif;
				background: var(--bg-body);
				color: var(--text-main);
				min-height: 100vh;
				display: flex;
				flex-direction: column;
			}

			/* Nav */
			nav {
				position: sticky;
				top: 0;
				z-index: 50;
				background: rgba(255, 255, 255, 0.85);
				backdrop-filter: blur(12px);
				border-bottom: 1px solid var(--border);
				height: 64px;
				display: flex;
				align-items: center;
				justify-content: center;
				padding: 0 1.5rem;
			}
			.nav-inner {
				width: 100%;
				max-width: 1000px;
				display: flex;
				justify-content: space-between;
				align-items: center;
			}
			.nav-actions {
				display: flex;
				align-items: center;
				gap: 1rem;
			}
			.brand {
				display: flex;
				align-items: center;
				gap: 0.75rem;
				font-weight: 700;
				font-size: 1.1rem;
			}
			.lang-switcher {
				display: flex;
				gap: 0.25rem;
				background: var(--bg-surface);
				border: 1px solid var(--border);
				border-radius: 8px;
				padding: 4px;
			}
			.lang-btn {
				padding: 4px 12px;
				border: none;
				background: none;
				border-radius: 6px;
				cursor: pointer;
				font-size: 0.875rem;
				font-weight: 600;
				color: var(--text-sub);
				transition: 0.2s;
			}
			.lang-btn:hover {
				background: var(--bg-body);
			}
			.lang-btn.active {
				background: var(--primary);
				color: white;
			}
			.brand-icon {
				width: 32px;
				height: 32px;
				background: linear-gradient(135deg, #4f46e5, #818cf8);
				border-radius: 8px;
				display: grid;
				place-items: center;
				color: white;
			}

			/* Main */
			main {
				flex: 1;
				width: 100%;
				max-width: 1000px;
				margin: 0 auto;
				padding: 2rem 1.5rem;
				display: flex;
				flex-direction: column;
				gap: 1.5rem;
			}

			/* Upload */
			.upload-section {
				background: var(--bg-surface);
				border: 2px dashed var(--border);
				border-radius: var(--radius-lg);
				padding: 3rem 1.5rem;
				text-align: center;
				transition: 0.2s;
				cursor: pointer;
			}
			.upload-section:hover {
				border-color: var(--primary);
				background: #f5f3ff;
				transform: translateY(-2px);
			}
			.upload-content h2 {
				margin-bottom: 0.5rem;
				font-weight: 700;
			}
			.upload-content p {
				color: var(--text-sub);
				margin-bottom: 1.5rem;
				font-size: 0.9rem;
			}

			/* Buttons */
			.btn {
				display: inline-flex;
				align-items: center;
				justify-content: center;
				gap: 0.5rem;
				padding: 0.6rem 1.2rem;
				border-radius: 10px;
				font-weight: 600;
				font-size: 0.875rem;
				transition: 0.2s;
				cursor: pointer;
				border: 1px solid transparent;
			}
			.btn-primary {
				background: var(--primary);
				color: white;
				box-shadow: 0 4px 6px -1px rgba(79, 70, 229, 0.2);
			}
			.btn-primary:hover:not(:disabled) {
				background: var(--primary-hover);
				transform: translateY(-1px);
			}
			.btn-primary:disabled {
				background: #94a3b8;
				cursor: not-allowed;
				box-shadow: none;
			}
			.btn-secondary {
				background: white;
				border-color: var(--border);
				color: var(--text-main);
			}
			.btn-secondary:hover {
				border-color: #cbd5e1;
				background: #f1f5f9;
			}
			.btn-block {
				width: 100%;
				padding: 12px;
				justify-content: space-between;
			} /* Export menu items */

			/* Grid */
			.grid-container {
				display: grid;
				grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
				gap: 1rem;
			}
			.card {
				background: white;
				border: 1px solid var(--border);
				border-radius: var(--radius-md);
				padding: 1.25rem;
				position: relative;
				transition: 0.2s;
				display: flex;
				flex-direction: column;
				gap: 1rem;
			}
			.card:hover {
				border-color: #cbd5e1;
				box-shadow: var(--shadow-sm);
				transform: translateY(-2px);
			}
			.card-header {
				display: flex;
				gap: 1rem;
				align-items: flex-start;
			}
			.service-icon {
				width: 42px;
				height: 42px;
				background: #f8fafc;
				border-radius: 10px;
				display: grid;
				place-items: center;
				border: 1px solid var(--border);
				color: var(--text-sub);
				flex-shrink: 0;
			}
			.card-info {
				flex: 1;
				min-width: 0;
			}
			.card-title {
				font-weight: 700;
				margin-bottom: 2px;
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
			}
			.card-subtitle {
				font-size: 0.8rem;
				color: var(--text-sub);
				display: block;
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
			}
			.tags {
				display: flex;
				gap: 6px;
				margin-top: 6px;
			}
			.tag {
				font-size: 0.7rem;
				padding: 2px 8px;
				border-radius: 6px;
				background: #f1f5f9;
				border: 1px solid var(--border);
				color: var(--text-sub);
				font-weight: 600;
			}
			.tag.totp {
				background: #eff6ff;
				color: var(--primary);
				border-color: #c7d2fe;
			}

			.delete-btn {
				background: #fef2f2;
				border: 1px solid #fecaca;
				color: #dc2626;
				cursor: pointer;
				padding: 6px 12px;
				border-radius: 8px;
				font-size: 0.875rem;
				font-weight: 600;
				transition: 0.2s;
			}
			.delete-btn:hover {
				background: #fee2e2;
				border-color: #fca5a5;
				color: #b91c1c;
			}

			.btn-danger {
				background: #fee2e2;
				border: 1px solid #fca5a5;
				color: #dc2626;
			}
			.btn-danger:hover {
				background: #fecaca;
				border-color: #f87171;
				color: #b91c1c;
			}

			/* Stats Bar */
			.stats-bar {
				display: flex;
				justify-content: space-between;
				align-items: center;
				background: white;
				padding: 1rem;
				border-radius: var(--radius-md);
				border: 1px solid var(--border);
				box-shadow: var(--shadow-sm);
			}
			.hidden {
				display: none !important;
			}

			/* Modals */
			.modal-overlay {
				position: fixed;
				inset: 0;
				background: rgba(0, 0, 0, 0.5);
				backdrop-filter: blur(4px);
				z-index: 100;
				display: flex;
				justify-content: center;
				align-items: center;
				opacity: 0;
				visibility: hidden;
				transition: 0.2s;
			}
			.modal-overlay.show {
				opacity: 1;
				visibility: visible;
			}
			.modal {
				background: white;
				width: 90%;
				max-width: 450px;
				padding: 1.5rem;
				border-radius: 16px;
				box-shadow: var(--shadow-lg);
				transform: scale(0.95);
				transition: 0.2s;
			}
			.modal-overlay.show .modal {
				transform: scale(1);
			}

			/* Export Menu */
			.export-option {
				display: flex;
				align-items: center;
				gap: 1rem;
				padding: 1rem;
				border: 1px solid var(--border);
				border-radius: 10px;
				margin-bottom: 0.75rem;
				cursor: pointer;
				transition: 0.2s;
				text-align: left;
				background: white;
				width: 100%;
			}
			.export-option:hover {
				border-color: var(--primary);
				background: #f5f3ff;
			}
			.export-icon {
				width: 36px;
				height: 36px;
				background: #e0e7ff;
				color: var(--primary);
				border-radius: 8px;
				display: grid;
				place-items: center;
				flex-shrink: 0;
			}
			.export-info h4 {
				margin: 0 0 2px 0;
				font-size: 0.95rem;
			}
			.export-info p {
				margin: 0;
				font-size: 0.8rem;
				color: var(--text-sub);
			}

			/* Progress */
			.progress-bar {
				height: 6px;
				background: #f1f5f9;
				border-radius: 99px;
				overflow: hidden;
				margin-top: 8px;
			}
			.progress-fill {
				height: 100%;
				background: var(--primary);
				width: 0%;
				transition: width 0.3s;
			}

			/* Toast */
			.toast-container {
				position: fixed;
				bottom: 20px;
				right: 20px;
				z-index: 200;
				display: flex;
				flex-direction: column;
				gap: 10px;
			}
			.toast {
				background: white;
				padding: 12px 16px;
				border-radius: 10px;
				border: 1px solid var(--border);
				box-shadow: var(--shadow-lg);
				display: flex;
				align-items: center;
				gap: 10px;
				animation: slideIn 0.3s;
				font-size: 0.9rem;
				font-weight: 500;
			}
			.toast.success {
				border-left: 4px solid var(--success);
			}
			.toast.error {
				border-left: 4px solid var(--error);
			}
			@keyframes slideIn {
				from {
					transform: translateY(20px);
					opacity: 0;
				}
				to {
					transform: translateY(0);
					opacity: 1;
				}
			}

			/* Card Actions */
			.card-actions {
				display: flex;
				gap: 0.5rem;
				padding-top: 0.75rem;
				border-top: 1px solid var(--border);
			}
			.btn-sm {
				padding: 0.5rem 1rem;
				font-size: 0.8rem;
			}
			.btn-icon {
				display: inline-flex;
				align-items: center;
				gap: 0.4rem;
			}

			/* QR Code Modal */
			.qr-modal-content {
				text-align: center;
			}
			.qr-canvas {
				margin: 1.5rem auto;
				border: 1px solid var(--border);
				border-radius: 12px;
				padding: 1rem;
				background: white;
				max-width: 100%;
			}
			.qr-info {
				background: #f8fafc;
				padding: 1rem;
				border-radius: 10px;
				margin-top: 1rem;
				text-align: left;
			}
			.qr-info-row {
				display: flex;
				justify-content: space-between;
				padding: 0.5rem 0;
				border-bottom: 1px solid var(--border);
				gap: 1rem;
				align-items: center;
			}
			.qr-info-row:last-child {
				border-bottom: none;
			}
			.qr-info-label {
				font-weight: 600;
				color: var(--text-sub);
				font-size: 0.85rem;
				flex-shrink: 0;
			}
			.qr-info-value {
				color: var(--text-main);
				font-weight: 600;
				font-size: 0.85rem;
				text-align: right;
				overflow: hidden;
				text-overflow: ellipsis;
				white-space: nowrap;
				min-width: 0;
			}

			/* Confirm Modal */
			.confirm-modal {
				max-width: 400px;
			}
			.confirm-icon {
				width: 56px;
				height: 56px;
				background: #fef2f2;
				color: var(--error);
				border-radius: 50%;
				display: grid;
				place-items: center;
				margin: 0 auto 1rem auto;
			}
			.confirm-actions {
				display: flex;
				gap: 0.75rem;
				margin-top: 1.5rem;
			}
			.confirm-actions button {
				flex: 1;
			}

			/* Info Banner */
			.info-banner {
				background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
				border: 1px solid #bae6fd;
				border-bottom: 2px solid #7dd3fc;
				padding: 1rem 1.25rem;
				display: flex;
				align-items: flex-start;
				gap: 0.75rem;
				box-shadow: 0 2px 4px 0 rgba(59, 130, 246, 0.08);
				position: sticky;
				top: 64px;
				z-index: 40;
				backdrop-filter: blur(8px);
				background: linear-gradient(
					135deg,
					rgba(240, 249, 255, 0.95) 0%,
					rgba(224, 242, 254, 0.95) 100%
				);
			}
			.info-banner-icon {
				width: 20px;
				height: 20px;
				color: #0284c7;
				flex-shrink: 0;
				margin-top: 2px;
			}
			.info-banner-content {
				flex: 1;
			}
			.info-banner-title {
				font-weight: 600;
				color: #0c4a6e;
				font-size: 0.9rem;
				margin-bottom: 0.25rem;
			}
			.info-banner-text {
				color: #075985;
				font-size: 0.85rem;
				line-height: 1.5;
			}
			.info-banner-highlight {
				color: #0369a1;
				font-weight: 600;
			}

			@media (max-width: 640px) {
				.stats-bar {
					flex-direction: column;
					align-items: stretch;
					gap: 1rem;
				}
			}
		</style>
	</head>
	<body>
		<nav>
			<div class="nav-inner">
				<div class="brand">
					<div class="brand-icon">
						<svg
							width="20"
							height="20"
							viewBox="0 0 24 24"
							fill="none"
							stroke="currentColor"
							stroke-width="2.5"
						>
							<path
								d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"
							/>
						</svg>
					</div>
					<span id="navTitle">GAuth è¿ç§»åŠ©æ‰‹ Pro</span>
				</div>
				<div class="nav-actions">
					<div class="lang-switcher">
						<button
							class="lang-btn active"
							data-lang="zh"
							onclick="setLanguage('zh')"
						>
							ä¸­æ–‡
						</button>
						<button
							class="lang-btn"
							data-lang="en"
							onclick="setLanguage('en')"
						>
							EN
						</button>
					</div>
					<button
						class="btn btn-primary"
						id="exportMenuBtn"
						disabled
						onclick="openModal('exportModal')"
					>
						<span id="exportBtnText">å¯¼å‡ºæ•°æ®</span>
						<svg
							width="16"
							height="16"
							viewBox="0 0 24 24"
							fill="none"
							stroke="currentColor"
							stroke-width="2"
						>
							<path d="M6 9l6 6 6-6" />
						</svg>
					</button>
				</div>
			</div>
		</nav>

		<main>
			<div class="upload-section" id="dropZone">
				<input
					type="file"
					id="fileInput"
					accept="image/*"
					multiple
					hidden
				/>
				<div class="upload-content">
					<div
						style="
							width: 64px;
							height: 64px;
							background: #eff6ff;
							color: #4f46e5;
							border-radius: 20px;
							display: grid;
							place-items: center;
							margin: 0 auto 1.25rem auto;
							box-shadow: 0 4px 6px -1px rgba(79, 70, 229, 0.1);
						"
					>
						<svg
							width="32"
							height="32"
							viewBox="0 0 24 24"
							fill="none"
							stroke="currentColor"
							stroke-width="2"
						>
							<path
								d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"
							/>
							<path d="M12 8v4" />
							<path d="M12 16h.01" />
						</svg>
					</div>

					<h2
						style="
							color: var(--text-main);
							letter-spacing: -0.025em;
						"
					>
						Google Authenticator çº¯æœ¬åœ°åŒ–è¿ç§»
					</h2>

					<p
						style="
							max-width: 400px;
							margin: 0.5rem auto 1.5rem auto;
							line-height: 1.6;
						"
					>
						<span style="color: var(--success); font-weight: 600"
							>å…¨ç¨‹æµè§ˆå™¨ç¦»çº¿å¤„ç†</span
						>ã€åŒå¼•æ“è§£æã€è‡ªåŠ¨å¢å¼ºå»å™ªã€æ”¯æŒæ‰¹é‡å¤„ç†
					</p>
					<div
						style="
							display: flex;
							gap: 10px;
							justify-content: center;
						"
					>
						<button
							class="btn btn-primary"
							onclick="document.getElementById('fileInput').click()"
						>
							é€‰æ‹©å›¾ç‰‡
						</button>
						<button
							class="btn btn-secondary"
							onclick="openModal('manualModal')"
						>
							é“¾æ¥è§£æ
						</button>
					</div>
				</div>
			</div>

			<div class="info-banner hidden" id="infoBanner">
				<svg
					class="info-banner-icon"
					viewBox="0 0 24 24"
					fill="none"
					stroke="currentColor"
					stroke-width="2"
				>
					<circle cx="12" cy="12" r="10" />
					<line x1="12" y1="16" x2="12" y2="12" />
					<line x1="12" y1="8" x2="12.01" y2="8" />
				</svg>
				<div class="info-banner-content">
					<div class="info-banner-title">ğŸ”’ æ•°æ®å®‰å…¨æç¤º</div>
					<div class="info-banner-text">
						æ‚¨çš„è´¦æˆ·æ•°æ®å·²å®‰å…¨ä¿å­˜åœ¨æœ¬åœ°æµè§ˆå™¨ä¸­ï¼ˆ15åˆ†é’Ÿåè‡ªåŠ¨æ¸…é™¤ï¼‰ã€‚<span
							class="info-banner-highlight"
							>å®Œæˆè¿ç§»åï¼Œè¯·åŠæ—¶ç‚¹å‡»"æ¸…ç©º"æŒ‰é’®åˆ é™¤æ‰€æœ‰æ•æ„Ÿæ•°æ®</span
						>ï¼Œç¡®ä¿è´¦æˆ·å®‰å…¨ã€‚
					</div>
				</div>
			</div>

			<div class="stats-bar hidden" id="statsBar">
				<div style="font-weight: 600">
					å·²è§£æ
					<span id="countDisplay" style="color: var(--primary)"
						>0</span
					>
					ä¸ªè´¦æˆ·
				</div>
				<div style="display: flex; gap: 10px">
					<input
						type="text"
						id="searchInput"
						placeholder="æœç´¢..."
						style="
							padding: 8px 12px;
							border: 1px solid var(--border);
							border-radius: 8px;
							outline: none;
						"
					/>
					<button class="btn btn-danger" onclick="confirmClearAll()">
						æ¸…ç©º
					</button>
				</div>
			</div>

			<div class="grid-container" id="gridContainer"></div>
			<div
				id="emptyState"
				style="text-align: center; padding: 3rem; color: #94a3b8"
			>
				æš‚æ— æ•°æ®
			</div>
		</main>

		<div class="modal-overlay" id="exportModal">
			<div class="modal">
				<div
					style="
						display: flex;
						justify-content: space-between;
						margin-bottom: 1.5rem;
						align-items: center;
					"
				>
					<h3 style="margin: 0">é€‰æ‹©å¯¼å‡ºæ ¼å¼</h3>
					<button
						onclick="closeModal('exportModal')"
						style="
							background: none;
							border: none;
							font-size: 1.5rem;
							color: var(--text-sub);
							cursor: pointer;
							line-height: 1;
						"
					>
						&times;
					</button>
				</div>

				<button class="export-option" onclick="exportData('bitwarden')">
					<div class="export-icon">
						<svg
							width="20"
							height="20"
							viewBox="0 0 24 24"
							fill="none"
							stroke="currentColor"
							stroke-width="2"
						>
							<path
								d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"
							/>
						</svg>
					</div>
					<div class="export-info">
						<h4>Bitwarden (JSON)</h4>
						<p>é€‚ç”¨äº Bitwarden, Vaultwarden å¯¼å…¥</p>
					</div>
				</button>

				<button class="export-option" onclick="exportData('csv')">
					<div class="export-icon">
						<svg
							width="20"
							height="20"
							viewBox="0 0 24 24"
							fill="none"
							stroke="currentColor"
							stroke-width="2"
						>
							<path
								d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"
							/>
							<polyline points="14 2 14 8 20 8" />
							<line x1="16" y1="13" x2="8" y2="13" />
							<line x1="16" y1="17" x2="8" y2="17" />
							<polyline points="10 9 9 9 8 9" />
						</svg>
					</div>
					<div class="export-info">
						<h4>é€šç”¨ CSV</h4>
						<p>é€‚ç”¨äº 1Password, KeePass, Enpass, LastPass</p>
					</div>
				</button>

				<button class="export-option" onclick="exportData('txt')">
					<div class="export-icon">
						<svg
							width="20"
							height="20"
							viewBox="0 0 24 24"
							fill="none"
							stroke="currentColor"
							stroke-width="2"
						>
							<line x1="8" y1="6" x2="21" y2="6" />
							<line x1="8" y1="12" x2="21" y2="12" />
							<line x1="8" y1="18" x2="21" y2="18" />
							<line x1="3" y1="6" x2="3.01" y2="6" />
							<line x1="3" y1="12" x2="3.01" y2="12" />
							<line x1="3" y1="18" x2="3.01" y2="18" />
						</svg>
					</div>
					<div class="export-info">
						<h4>çº¯ URI æ–‡æœ¬ (.txt)</h4>
						<p>é€‚ç”¨äº Aegis, 2FAS æˆ–ç”Ÿæˆæ–°äºŒç»´ç  (ä¸‡èƒ½æ ¼å¼)</p>
					</div>
				</button>

				<button class="export-option" onclick="exportQRCodes()">
					<div class="export-icon">
						<svg
							width="20"
							height="20"
							viewBox="0 0 24 24"
							fill="none"
							stroke="currentColor"
							stroke-width="2"
						>
							<rect x="3" y="3" width="7" height="7" />
							<rect x="14" y="3" width="7" height="7" />
							<rect x="3" y="14" width="7" height="7" />
							<rect x="14" y="14" width="7" height="7" />
						</svg>
					</div>
					<div class="export-info">
						<h4>äºŒç»´ç æ‰“åŒ… (.zip)</h4>
						<p>ä¸ºæ¯ä¸ªå¯†é’¥ç”ŸæˆäºŒç»´ç å›¾ç‰‡å¹¶æ‰“åŒ…ä¸‹è½½</p>
					</div>
				</button>
			</div>
		</div>

		<div class="modal-overlay" id="progressModal">
			<div class="modal" style="text-align: center">
				<h3 style="margin-bottom: 0.5rem">æ­£åœ¨å¤„ç†</h3>
				<p
					id="progressText"
					style="
						color: var(--text-sub);
						font-size: 0.9rem;
						margin-bottom: 10px;
					"
				>
					åˆå§‹åŒ–...
				</p>
				<div class="progress-bar">
					<div class="progress-fill" id="progressFill"></div>
				</div>
			</div>
		</div>

		<div class="modal-overlay" id="manualModal">
			<div class="modal">
				<div
					style="
						display: flex;
						justify-content: space-between;
						margin-bottom: 1rem;
						align-items: center;
					"
				>
					<h3 style="margin: 0">æ‰‹åŠ¨è§£æ</h3>
					<button
						onclick="closeModal('manualModal')"
						style="
							background: none;
							border: none;
							font-size: 1.5rem;
							color: var(--text-sub);
							cursor: pointer;
							line-height: 1;
						"
					>
						&times;
					</button>
				</div>
				<textarea
					id="manualInput"
					style="
						width: 100%;
						height: 120px;
						border: 1px solid var(--border);
						border-radius: 10px;
						padding: 12px;
						font-family: monospace;
						font-size: 0.85rem;
						resize: vertical;
					"
					placeholder="ç²˜è´´ otpauth-migration://..."
				></textarea>
				<button
					class="btn btn-primary"
					style="width: 100%; margin-top: 1rem"
					onclick="processManual()"
				>
					ç¡®è®¤è§£æ
				</button>
			</div>
		</div>

		<!-- QR Code Modal -->
		<div class="modal-overlay" id="qrModal">
			<div class="modal">
				<div
					style="
						display: flex;
						justify-content: space-between;
						margin-bottom: 1rem;
						align-items: center;
						gap: 1rem;
					"
				>
					<h3
						id="qrModalTitle"
						style="
							margin: 0;
							overflow: hidden;
							text-overflow: ellipsis;
							white-space: nowrap;
							flex: 1;
							min-width: 0;
						"
					>
						äºŒç»´ç 
					</h3>
					<button
						onclick="closeModal('qrModal')"
						style="
							background: none;
							border: none;
							font-size: 1.5rem;
							color: var(--text-sub);
							cursor: pointer;
							line-height: 1;
							flex-shrink: 0;
						"
					>
						&times;
					</button>
				</div>
				<div class="qr-modal-content">
					<canvas id="qrCanvas" class="qr-canvas"></canvas>
					<div class="qr-info" id="qrInfo"></div>
				</div>
			</div>
		</div>

		<!-- Confirm Modal -->
		<div class="modal-overlay" id="confirmModal">
			<div class="modal confirm-modal">
				<div class="confirm-icon">
					<svg
						width="28"
						height="28"
						viewBox="0 0 24 24"
						fill="none"
						stroke="currentColor"
						stroke-width="2"
					>
						<circle cx="12" cy="12" r="10" />
						<line x1="12" y1="8" x2="12" y2="12" />
						<line x1="12" y1="16" x2="12.01" y2="16" />
					</svg>
				</div>
				<h3
					id="confirmTitle"
					style="text-align: center; margin-bottom: 0.5rem"
				>
					ç¡®è®¤æ“ä½œ
				</h3>
				<p
					id="confirmMessage"
					style="
						text-align: center;
						color: var(--text-sub);
						font-size: 0.9rem;
					"
				>
					æ­¤æ“ä½œæ— æ³•æ’¤é”€
				</p>
				<div class="confirm-actions">
					<button
						class="btn btn-secondary"
						onclick="closeModal('confirmModal')"
					>
						å–æ¶ˆ
					</button>
					<button
						class="btn btn-danger"
						id="confirmBtn"
						onclick="handleConfirm()"
					>
						ç¡®è®¤
					</button>
				</div>
			</div>
		</div>

		<div class="toast-container" id="toastContainer"></div>

		<script src="https://cdn.jsdelivr.net/npm/@zxing/library@0.20.0/umd/index.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

		<script>
			// === i18n Configuration ===
			const i18n = {
				zh: {
					// Navigation
					appTitle: "GAuth è¿ç§»åŠ©æ‰‹ Pro",
					exportBtn: "å¯¼å‡ºæ•°æ®",

					// Upload Section
					uploadTitle: "Google Authenticator çº¯æœ¬åœ°åŒ–è¿ç§»",
					uploadDesc:
						'<span style="color: var(--success); font-weight: 600">å…¨ç¨‹æµè§ˆå™¨ç¦»çº¿å¤„ç†</span>ã€åŒå¼•æ“è§£æã€è‡ªåŠ¨å¢å¼ºå»å™ªã€æ”¯æŒæ‰¹é‡å¤„ç†',
					selectImages: "é€‰æ‹©å›¾ç‰‡",
					linkParse: "é“¾æ¥è§£æ",

					// Info Banner
					infoBannerTitle: "ğŸ”’ æ•°æ®å®‰å…¨æç¤º",
					infoBannerText:
						'æ‚¨çš„è´¦æˆ·æ•°æ®å·²å®‰å…¨ä¿å­˜åœ¨æœ¬åœ°æµè§ˆå™¨ä¸­ï¼ˆ15åˆ†é’Ÿåè‡ªåŠ¨æ¸…é™¤ï¼‰ã€‚<span class="info-banner-highlight">å®Œæˆè¿ç§»åï¼Œè¯·åŠæ—¶ç‚¹å‡»"æ¸…ç©º"æŒ‰é’®åˆ é™¤æ‰€æœ‰æ•æ„Ÿæ•°æ®</span>ï¼Œç¡®ä¿è´¦æˆ·å®‰å…¨ã€‚',

					// Stats Bar
					parsed: "å·²è§£æ",
					accounts: "ä¸ªè´¦æˆ·",
					search: "æœç´¢...",
					clear: "æ¸…ç©º",

					// Empty State
					emptyState: "æš‚æ— æ•°æ®",

					// Modals - Export
					exportModalTitle: "é€‰æ‹©å¯¼å‡ºæ ¼å¼",
					exportBitwarden: "Bitwarden (JSON)",
					exportBitwardenDesc: "é€‚ç”¨äº Bitwarden, Vaultwarden å¯¼å…¥",
					exportCSV: "é€šç”¨ CSV",
					exportCSVDesc:
						"é€‚ç”¨äº 1Password, KeePass, Enpass, LastPass",
					exportTxt: "çº¯ URI æ–‡æœ¬ (.txt)",
					exportTxtDesc:
						"é€‚ç”¨äº Aegis, 2FAS æˆ–ç”Ÿæˆæ–°äºŒç»´ç  (ä¸‡èƒ½æ ¼å¼)",
					exportQR: "äºŒç»´ç æ‰“åŒ… (.zip)",
					exportQRDesc: "ä¸ºæ¯ä¸ªå¯†é’¥ç”ŸæˆäºŒç»´ç å›¾ç‰‡å¹¶æ‰“åŒ…ä¸‹è½½",

					// Modals - Progress
					progressTitle: "æ­£åœ¨å¤„ç†",
					progressInit: "åˆå§‹åŒ–...",

					// Modals - Manual
					manualTitle: "æ‰‹åŠ¨è§£æ",
					manualPlaceholder: "ç²˜è´´ otpauth-migration://...",
					manualConfirm: "ç¡®è®¤è§£æ",

					// Modals - QR
					qrTitle: "äºŒç»´ç ",
					qrAccount: "è´¦æˆ·åç§°",
					qrIssuer: "å‘è¡Œè€…",
					qrType: "ç±»å‹",
					qrAlgo: "ç®—æ³•",
					qrUnknown: "æœªçŸ¥",

					// Modals - Confirm
					confirmTitle: "ç¡®è®¤æ“ä½œ",
					confirmMessage: "æ­¤æ“ä½œæ— æ³•æ’¤é”€",
					confirmCancel: "å–æ¶ˆ",
					confirmOK: "ç¡®è®¤",

					// Card
					cardQR: "äºŒç»´ç ",
					cardDelete: "åˆ é™¤",
					cardUnnamed: "æœªå‘½åè´¦æˆ·",

					// Toast Messages
					toastRecovered:
						"å·²æ¢å¤ {count} ä¸ªè´¦æˆ·ï¼ˆæ•°æ®å°†åœ¨15åˆ†é’Ÿåè‡ªåŠ¨æ¸…é™¤ï¼‰",
					toastAllSuccess: "ğŸ‰ æˆåŠŸè§£æå…¨éƒ¨ {count} å¼ å›¾ç‰‡ï¼",
					toastPartialSuccess:
						"å®Œæˆï¼šæˆåŠŸ {success} å¼ ï¼Œå¤±è´¥ {fail} å¼ ï¼ˆæŸ¥çœ‹æ§åˆ¶å°äº†è§£è¯¦æƒ…ï¼‰",
					toastAllFailed:
						"è§£æå¤±è´¥ï¼Œè¯·æ£€æŸ¥å›¾ç‰‡è´¨é‡æˆ–å°è¯•æ‰‹åŠ¨è¾“å…¥é“¾æ¥",
					toastExportSuccess: "å¯¼å‡ºæˆåŠŸ",
					toastDeleteSuccess: "åˆ é™¤æˆåŠŸ",
					toastClearSuccess: "å·²æ¸…ç©ºæ‰€æœ‰æ•°æ®",
					toastParseSuccess: "âœ… æˆåŠŸè§£æ {count} ä¸ªè´¦æˆ·",
					toastNoAccounts: "æœªæ‰¾åˆ°æœ‰æ•ˆè´¦æˆ·",
					toastInvalidInput: "è¯·è¾“å…¥é“¾æ¥",
					toastQRExportSuccess: "æˆåŠŸå¯¼å‡º {count} ä¸ªäºŒç»´ç ",
					toastNoExport: "æ²¡æœ‰å¯å¯¼å‡ºçš„è´¦æˆ·",

					// Error Messages
					errorInvalidLink:
						"è¯·è¾“å…¥æœ‰æ•ˆçš„ Google Authenticator è¿ç§»é“¾æ¥",
					errorMissingData: "é“¾æ¥æ ¼å¼é”™è¯¯ï¼šç¼ºå°‘æ•°æ®éƒ¨åˆ†",
					errorBase64: "æ•°æ®æ ¼å¼é”™è¯¯ï¼šæ— æ³•è§£ç ",
					errorProtobuf: "æ•°æ®æŸåï¼š",
					errorQRGeneration: "äºŒç»´ç ç”Ÿæˆå¤±è´¥",
					errorExportFailed: "å¯¼å‡ºå¤±è´¥",

					// Confirm Dialog
					confirmDelete: "ç¡®å®šåˆ é™¤ï¼Ÿ",
					confirmDeleteMsg: "æ­¤æ“ä½œå°†ä»åˆ—è¡¨åˆ é™¤è¯¥è´¦æˆ·",
					confirmClearAll: "ç¡®å®šæ¸…ç©ºæ‰€æœ‰è´¦æˆ·ï¼Ÿ",
					confirmClearAllMsg:
						"æ­¤æ“ä½œå°†æ°¸ä¹…åˆ é™¤æ‰€æœ‰æ•æ„Ÿæ•°æ®ï¼Œæ— æ³•æ¢å¤",
				},
				en: {
					// Navigation
					appTitle: "GAuth Migrator Pro",
					exportBtn: "Export Data",

					// Upload Section
					uploadTitle: "Google Authenticator Local Migration",
					uploadDesc:
						'<span style="color: var(--success); font-weight: 600">100% Offline Browser Processing</span>, Dual-Engine Parsing, Auto-Enhancement, Batch Support',
					selectImages: "Select Images",
					linkParse: "Parse Link",

					// Info Banner
					infoBannerTitle: "ğŸ”’ Data Security Notice",
					infoBannerText:
						'Your account data is securely stored in your local browser (auto-deleted after 15 minutes). <span class="info-banner-highlight">After migration, please click the "Clear" button to delete all sensitive data</span> to ensure account security.',

					// Stats Bar
					parsed: "Parsed",
					accounts: "accounts",
					search: "Search...",
					clear: "Clear",

					// Empty State
					emptyState: "No data",

					// Modals - Export
					exportModalTitle: "Select Export Format",
					exportBitwarden: "Bitwarden (JSON)",
					exportBitwardenDesc: "For Bitwarden, Vaultwarden import",
					exportCSV: "Universal CSV",
					exportCSVDesc: "For 1Password, KeePass, Enpass, LastPass",
					exportTxt: "Plain URI Text (.txt)",
					exportTxtDesc:
						"For Aegis, 2FAS or generate new QR codes (universal format)",
					exportQR: "QR Code Package (.zip)",
					exportQRDesc:
						"Generate QR code images for each key and package for download",

					// Modals - Progress
					progressTitle: "Processing",
					progressInit: "Initializing...",

					// Modals - Manual
					manualTitle: "Manual Parse",
					manualPlaceholder: "Paste otpauth-migration://...",
					manualConfirm: "Confirm Parse",

					// Modals - QR
					qrTitle: "QR Code",
					qrAccount: "Account Name",
					qrIssuer: "Issuer",
					qrType: "Type",
					qrAlgo: "Algorithm",
					qrUnknown: "Unknown",

					// Modals - Confirm
					confirmTitle: "Confirm Action",
					confirmMessage: "This action cannot be undone",
					confirmCancel: "Cancel",
					confirmOK: "Confirm",

					// Card
					cardQR: "QR Code",
					cardDelete: "Delete",
					cardUnnamed: "Unnamed Account",

					// Toast Messages
					toastRecovered:
						"Recovered {count} accounts (data will auto-delete after 15 minutes)",
					toastAllSuccess:
						"ğŸ‰ Successfully parsed all {count} images!",
					toastPartialSuccess:
						"Completed: {success} succeeded, {fail} failed (check console for details)",
					toastAllFailed:
						"Parsing failed, please check image quality or try manual input",
					toastExportSuccess: "Export successful",
					toastDeleteSuccess: "Deleted successfully",
					toastClearSuccess: "All data cleared",
					toastParseSuccess:
						"âœ… Successfully parsed {count} accounts",
					toastNoAccounts: "No valid accounts found",
					toastInvalidInput: "Please enter a link",
					toastQRExportSuccess:
						"Successfully exported {count} QR codes",
					toastNoExport: "No accounts to export",

					// Error Messages
					errorInvalidLink:
						"Please enter a valid Google Authenticator migration link",
					errorMissingData: "Link format error: missing data field",
					errorBase64: "Data format error: cannot decode",
					errorProtobuf: "Data corrupted: ",
					errorQRGeneration: "QR code generation failed",
					errorExportFailed: "Export failed",

					// Confirm Dialog
					confirmDelete: "Confirm Delete?",
					confirmDeleteMsg:
						"This will remove the account from the list",
					confirmClearAll: "Clear All Accounts?",
					confirmClearAllMsg:
						"This will permanently delete all sensitive data and cannot be undone",
				},
			};

			let currentLang = "zh";

			function t(key, params = {}) {
				let text = i18n[currentLang][key] || i18n.zh[key] || key;
				Object.keys(params).forEach((param) => {
					text = text.replace(`{${param}}`, params[param]);
				});
				return text;
			}

			function setLanguage(lang) {
				currentLang = lang;
				localStorage.setItem("preferred_language", lang);
				updateUILanguage();
			}

			function detectLanguage() {
				const saved = localStorage.getItem("preferred_language");
				if (saved) return saved;
				const browserLang =
					navigator.language || navigator.userLanguage;
				return browserLang.startsWith("zh") ? "zh" : "en";
			}

			function updateUILanguage() {
				// Update navigation
				document.getElementById("navTitle").textContent = t("appTitle");
				document.getElementById("exportBtnText").textContent =
					t("exportBtn");

				// Update upload section
				const uploadSection =
					document.querySelector(".upload-content h2");
				if (uploadSection) {
					uploadSection.textContent = t("uploadTitle");
				}
				const uploadDesc = document.querySelector(".upload-content p");
				if (uploadDesc) {
					uploadDesc.innerHTML = t("uploadDesc");
				}
				const selectImagesBtn = document.querySelector(
					".upload-content .btn-primary"
				);
				if (selectImagesBtn) {
					selectImagesBtn.textContent = t("selectImages");
				}
				const linkParseBtn = document.querySelector(
					".upload-content .btn-secondary"
				);
				if (linkParseBtn) {
					linkParseBtn.textContent = t("linkParse");
				}

				// Update info banner
				const infoBannerTitle =
					document.querySelector(".info-banner-title");
				if (infoBannerTitle) {
					infoBannerTitle.textContent = t("infoBannerTitle");
				}
				const infoBannerText =
					document.querySelector(".info-banner-text");
				if (infoBannerText) {
					infoBannerText.innerHTML = t("infoBannerText");
				}

				// Update stats bar
				const statsBarText = document.querySelector(
					"#statsBar > div:first-child"
				);
				if (statsBarText) {
					const count =
						document.getElementById("countDisplay").textContent;
					statsBarText.innerHTML = `${t(
						"parsed"
					)} <span id="countDisplay" style="color: var(--primary)">${count}</span> ${t(
						"accounts"
					)}`;
				}
				const searchInput = document.getElementById("searchInput");
				if (searchInput) {
					searchInput.placeholder = t("search");
				}
				const clearBtn = document.querySelector(
					"#statsBar .btn-danger"
				);
				if (clearBtn) {
					clearBtn.textContent = t("clear");
				}

				// Update empty state
				const emptyState = document.getElementById("emptyState");
				if (emptyState) {
					emptyState.textContent = t("emptyState");
				}

				// Update export modal
				document.querySelector("#exportModal h3").textContent =
					t("exportModalTitle");
				const exportOptions = document.querySelectorAll(
					"#exportModal .export-option"
				);
				if (exportOptions[0]) {
					exportOptions[0].querySelector("h4").textContent =
						t("exportBitwarden");
					exportOptions[0].querySelector("p").textContent = t(
						"exportBitwardenDesc"
					);
				}
				if (exportOptions[1]) {
					exportOptions[1].querySelector("h4").textContent =
						t("exportCSV");
					exportOptions[1].querySelector("p").textContent =
						t("exportCSVDesc");
				}
				if (exportOptions[2]) {
					exportOptions[2].querySelector("h4").textContent =
						t("exportTxt");
					exportOptions[2].querySelector("p").textContent =
						t("exportTxtDesc");
				}
				if (exportOptions[3]) {
					exportOptions[3].querySelector("h4").textContent =
						t("exportQR");
					exportOptions[3].querySelector("p").textContent =
						t("exportQRDesc");
				}

				// Update progress modal
				document.querySelector("#progressModal h3").textContent =
					t("progressTitle");
				const progressText = document.getElementById("progressText");
				if (progressText && progressText.textContent === "åˆå§‹åŒ–...") {
					progressText.textContent = t("progressInit");
				}

				// Update manual modal
				document.querySelector("#manualModal h3").textContent =
					t("manualTitle");
				const manualInput = document.getElementById("manualInput");
				if (manualInput) {
					manualInput.placeholder = t("manualPlaceholder");
				}
				const manualConfirmBtn = document.querySelector(
					"#manualModal .btn-primary"
				);
				if (manualConfirmBtn) {
					manualConfirmBtn.textContent = t("manualConfirm");
				}

				// Update confirm modal
				const confirmTitle = document.getElementById("confirmTitle");
				const confirmMessage =
					document.getElementById("confirmMessage");
				if (confirmTitle && confirmTitle.textContent === "ç¡®è®¤æ“ä½œ") {
					confirmTitle.textContent = t("confirmTitle");
				}
				if (
					confirmMessage &&
					confirmMessage.textContent === "æ­¤æ“ä½œæ— æ³•æ’¤é”€"
				) {
					confirmMessage.textContent = t("confirmMessage");
				}
				const confirmBtns = document.querySelectorAll(
					"#confirmModal button"
				);
				if (confirmBtns[0] && confirmBtns[0].textContent === "å–æ¶ˆ") {
					confirmBtns[0].textContent = t("confirmCancel");
				}
				if (confirmBtns[1] && confirmBtns[1].textContent === "ç¡®è®¤") {
					confirmBtns[1].textContent = t("confirmOK");
				}

				// Update language button active state
				document.querySelectorAll(".lang-btn").forEach((btn) => {
					btn.classList.toggle(
						"active",
						btn.dataset.lang === currentLang
					);
				});

				// Re-render account cards with translated text
				renderGrid();
			}

			// === State ===
			let state = { accounts: [] };
			const DB_NAME = "GAuthMigratorDB";
			const DB_VERSION = 1;
			const STORE_NAME = "accounts";
			const EXPIRY_MINUTES = 15;
			let db = null;

			// === IndexedDB Setup ===
			async function initDB() {
				return new Promise((resolve, reject) => {
					const request = indexedDB.open(DB_NAME, DB_VERSION);

					request.onerror = () => reject(request.error);
					request.onsuccess = () => {
						db = request.result;
						resolve(db);
					};

					request.onupgradeneeded = (event) => {
						const db = event.target.result;
						if (!db.objectStoreNames.contains(STORE_NAME)) {
							db.createObjectStore(STORE_NAME);
						}
					};
				});
			}

			async function saveToIndexedDB(data) {
				if (!db) return;
				try {
					const tx = db.transaction(STORE_NAME, "readwrite");
					const store = tx.objectStore(STORE_NAME);
					const record = {
						accounts: data,
						timestamp: Date.now(),
					};
					store.put(record, "data");
					await new Promise((resolve, reject) => {
						tx.oncomplete = resolve;
						tx.onerror = reject;
					});
				} catch (error) {
					console.error("ä¿å­˜åˆ° IndexedDB å¤±è´¥:", error);
				}
			}

			async function loadFromIndexedDB() {
				if (!db) return null;
				try {
					const tx = db.transaction(STORE_NAME, "readonly");
					const store = tx.objectStore(STORE_NAME);
					const request = store.get("data");

					return new Promise((resolve) => {
						request.onsuccess = () => {
							const data = request.result;
							if (!data) {
								resolve(null);
								return;
							}

							// æ£€æŸ¥æ˜¯å¦è¿‡æœŸï¼ˆ15åˆ†é’Ÿï¼‰
							const elapsed = Date.now() - data.timestamp;
							const expiryMs = EXPIRY_MINUTES * 60 * 1000;

							if (elapsed > expiryMs) {
								console.log("æ•°æ®å·²è¿‡æœŸï¼Œè‡ªåŠ¨æ¸…é™¤");
								clearIndexedDB();
								resolve(null);
							} else {
								resolve(data.accounts);
							}
						};
						request.onerror = () => resolve(null);
					});
				} catch (error) {
					console.error("ä» IndexedDB åŠ è½½å¤±è´¥:", error);
					return null;
				}
			}

			async function clearIndexedDB() {
				if (!db) return;
				try {
					const tx = db.transaction(STORE_NAME, "readwrite");
					const store = tx.objectStore(STORE_NAME);
					store.delete("data");
					await new Promise((resolve, reject) => {
						tx.oncomplete = resolve;
						tx.onerror = reject;
					});
				} catch (error) {
					console.error("æ¸…é™¤ IndexedDB å¤±è´¥:", error);
				}
			}

			// === Icons ===
			const ICONS = {
				github: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>',
				google: '<svg viewBox="0 0 24 24"><path fill="#EA4335" d="M12 5.04c1.86 0 3.52.66 4.82 1.88l3.6-3.6C18.24 1.24 15.34 0 12 0 7.4 0 3.38 2.64 1.43 6.53l4.2 3.26C6.6 6.86 9.07 5.04 12 5.04z"/><path fill="#34A853" d="M24 12.3c0-.85-.08-1.67-.22-2.46H12v4.66h6.76c-.3 1.54-1.16 2.84-2.47 3.72l3.98 3.09c2.32-2.14 3.67-5.29 3.67-9.01z"/><path fill="#4A90E2" d="M4.33 14.54c-.26-.77-.41-1.6-.41-2.46s.15-1.69.41-2.46L.13 6.36A11.96 11.96 0 0 0 0 12c0 1.98.48 3.86 1.33 5.54l4.33-3.26z"/><path fill="#FBBC05" d="M12 24c3.24 0 5.86-1.07 7.84-2.9l-3.98-3.09c-1.07.72-2.44 1.14-3.86 1.14-2.93 0-5.41-1.98-6.3-4.64l-4.2 3.26C3.38 21.36 7.4 24 12 24z"/></svg>',
				aws: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12.9 8.4c-1.9 0-3.3.4-3.3 2.7v.1c0 1.9 1.4 2.5 3.1 2.5 1.4 0 2.5-.5 2.5-1.9v-2c-.7-.9-1.5-1.4-2.3-1.4zm6.6-4.9c-.8-.4-1.7-.5-2.6-.5-3.3 0-5.3 1.7-6.1 4.2-1-.7-2.3-1.1-3.6-1.1-3.6 0-6 2.5-6 6.2 0 2.8 1.6 5 4.3 5 1.7 0 3-.6 3.9-1.8.3 1.1 1.3 1.7 2.6 1.7.9 0 1.8-.3 2.5-.7v-3.7c-.8.5-1.5.7-2.1.7-.6 0-1-.3-1-1v-4.9c0-2 .9-2.8 2.5-2.8.5 0 1 .1 1.4.3v-1.6z"/></svg>',
				default:
					'<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>',
			};

			// === DOM Events ===
			const dropZone = document.getElementById("dropZone");
			const fileInput = document.getElementById("fileInput");

			dropZone.addEventListener("dragover", (e) => {
				e.preventDefault();
				dropZone.style.borderColor = "var(--primary)";
				dropZone.style.background = "#f5f3ff";
			});
			dropZone.addEventListener("dragleave", () => {
				dropZone.style.borderColor = "var(--border)";
				dropZone.style.background = "var(--bg-surface)";
			});
			dropZone.addEventListener("drop", (e) => {
				e.preventDefault();
				dropZone.style.borderColor = "var(--border)";
				dropZone.style.background = "var(--bg-surface)";
				if (e.dataTransfer.files.length)
					handleBatchFiles(e.dataTransfer.files);
			});
			fileInput.addEventListener("change", (e) => {
				if (e.target.files.length) handleBatchFiles(e.target.files);
				fileInput.value = "";
			});
			document
				.getElementById("searchInput")
				.addEventListener("input", (e) => renderGrid(e.target.value));

			// === Core: Batch Processing ===
			async function handleBatchFiles(fileList) {
				openModal("progressModal");
				const files = Array.from(fileList);
				const total = files.length;
				let success = 0;
				const failedFiles = [];
				const MAX_RETRIES = 2;

				for (let i = 0; i < total; i++) {
					const file = files[i];
					let lastError = null;
					let retryCount = 0;
					let succeeded = false;

					// é‡è¯•æœºåˆ¶
					while (retryCount <= MAX_RETRIES && !succeeded) {
						try {
							const progressMsg =
								retryCount > 0
									? `${file.name} (é‡è¯• ${retryCount}/${MAX_RETRIES})`
									: file.name;
							updateProgress(i + 1, total, progressMsg);

							const rawText = await decodeViolently(file);
							const newAcc = parseProtobuf(rawText);

							if (newAcc && newAcc.length > 0) {
								mergeAccounts(newAcc);
								success++;
								succeeded = true;
								console.log(
									`âœ“ ${file.name}: æˆåŠŸè§£æ ${newAcc.length} ä¸ªè´¦æˆ·`
								);
							} else {
								throw new Error("æœªè§£æåˆ°ä»»ä½•è´¦æˆ·");
							}
						} catch (e) {
							lastError = e;
							retryCount++;

							if (retryCount <= MAX_RETRIES) {
								console.log(
									`âœ— ${file.name}: ${e.message}ï¼Œå‡†å¤‡é‡è¯•...`
								);
								await new Promise((r) => setTimeout(r, 300));
							}
						}
					}

					// è®°å½•å¤±è´¥çš„æ–‡ä»¶
					if (!succeeded) {
						failedFiles.push({
							name: file.name,
							error: lastError?.message || "æœªçŸ¥é”™è¯¯",
							type: lastError?.message.includes("è§£ç ")
								? "äºŒç»´ç è¯†åˆ«"
								: lastError?.message.includes("Protobuf")
								? "æ•°æ®è§£æ"
								: "å…¶ä»–",
						});
						console.error(
							`âœ— ${file.name}: æœ€ç»ˆå¤±è´¥ - ${lastError?.message}`
						);
					}

					await new Promise((r) => setTimeout(r, 50));
				}

				setTimeout(() => {
					closeModal("progressModal");
					renderGrid();

					const fail = failedFiles.length;
					if (success > 0) {
						if (fail === 0) {
							showToast(
								t("toastAllSuccess", { count: success }),
								"success"
							);
						} else {
							showToast(
								t("toastPartialSuccess", { success, fail }),
								"error"
							);
							console.group("âŒ å¤±è´¥æ–‡ä»¶è¯¦æƒ…");
							failedFiles.forEach((f) => {
								console.error(
									`ğŸ“„ ${f.name}\n   ç±»å‹: ${f.type}\n   åŸå› : ${f.error}`
								);
							});
							console.groupEnd();
						}
					} else {
						showToast(t("toastAllFailed"), "error");
						console.group("âŒ æ‰€æœ‰æ–‡ä»¶å‡å¤±è´¥");
						failedFiles.forEach((f) => {
							console.error(`ğŸ“„ ${f.name}: ${f.error}`);
						});
						console.groupEnd();
					}
				}, 500);
			}

			// === Core: Decoding (Hybrid Engine) ===
			async function decodeViolently(file) {
				let img = await loadImage(file);

				// æ€§èƒ½ä¼˜åŒ–ï¼šå¤§å›¾ç‰‡è‡ªåŠ¨ç¼©æ”¾
				const MAX_SIZE = 1500;
				if (img.width > MAX_SIZE || img.height > MAX_SIZE) {
					img = await resizeImage(img, MAX_SIZE);
				}

				// ç­–ç•¥1: æµè§ˆå™¨åŸç”ŸAPIï¼ˆæœ€å¿«æœ€å‡†ï¼‰
				if ("BarcodeDetector" in window) {
					try {
						const det = new BarcodeDetector({
							formats: ["qr_code"],
						});
						const bars = await det.detect(img);
						if (bars.length) return bars[0].rawValue;
					} catch (e) {
						console.log("BarcodeDetector å¤±è´¥:", e.message);
					}
				}

				// åˆ›å»ºå¤ç”¨çš„ canvas
				const canvas = document.createElement("canvas");
				canvas.width = img.width;
				canvas.height = img.height;
				const ctx = canvas.getContext("2d", {
					willReadFrequently: true,
				});

				// ä¼˜åŒ–çš„ç­–ç•¥åˆ—è¡¨ï¼ˆæŒ‰æˆåŠŸç‡æ’åºï¼‰
				const strategies = [
					{ name: "Raw", fn: null, engines: ["jsQR", "zxing"] },
					{ name: "Sharpen", fn: filterSharpen, engines: ["jsQR"] },
					{
						name: "AdaptiveBin",
						fn: filterAdaptiveBinarize,
						engines: ["jsQR"],
					},
					{
						name: "Bin-128",
						fn: (c, w, h) => filterBinarize(c, w, h, 128),
						engines: ["jsQR"],
					},
					{ name: "Denoise", fn: filterDenoise, engines: ["jsQR"] },
					{
						name: "HighContrast",
						fn: filterHighContrast,
						engines: ["jsQR", "zxing"],
					},
					{ name: "Invert", fn: filterInvert, engines: ["jsQR"] },
					{ name: "Scale-2x", scale: 2, fn: null, engines: ["jsQR"] },
				];

				const zxing = new ZXing.BrowserMultiFormatReader();

				for (const strat of strategies) {
					try {
						// è°ƒæ•´ canvas å¤§å°
						const scale = strat.scale || 1;
						if (scale !== 1) {
							canvas.width = img.width * scale;
							canvas.height = img.height * scale;
						} else {
							canvas.width = img.width;
							canvas.height = img.height;
						}

						// ç»˜åˆ¶å›¾åƒ
						ctx.clearRect(0, 0, canvas.width, canvas.height);
						ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

						// åº”ç”¨æ»¤é•œ
						if (strat.fn) {
							strat.fn(ctx, canvas.width, canvas.height);
						}

						// å°è¯•ä¸åŒçš„è§£ç å¼•æ“
						for (const engine of strat.engines) {
							if (engine === "jsQR" && window.jsQR) {
								const imgData = ctx.getImageData(
									0,
									0,
									canvas.width,
									canvas.height
								);
								const code = jsQR(
									imgData.data,
									canvas.width,
									canvas.height,
									{
										inversionAttempts: "dontInvert",
									}
								);
								if (code) {
									console.log(
										`æˆåŠŸç­–ç•¥: ${strat.name} (jsQR)`
									);
									return code.data;
								}
							} else if (engine === "zxing") {
								const dataUrl = canvas.toDataURL("image/png");
								const res = await zxing.decodeFromImage(
									undefined,
									dataUrl
								);
								if (res) {
									console.log(
										`æˆåŠŸç­–ç•¥: ${strat.name} (ZXing)`
									);
									return res.text;
								}
							}
						}
					} catch (e) {
						// ç»§ç»­å°è¯•ä¸‹ä¸€ä¸ªç­–ç•¥
					}
				}

				throw new Error("æ‰€æœ‰è§£ç ç­–ç•¥å‡å¤±è´¥");
			}

			function resizeImage(img, maxSize) {
				return new Promise((resolve) => {
					const canvas = document.createElement("canvas");
					let width = img.width;
					let height = img.height;

					if (width > height) {
						if (width > maxSize) {
							height = (height * maxSize) / width;
							width = maxSize;
						}
					} else {
						if (height > maxSize) {
							width = (width * maxSize) / height;
							height = maxSize;
						}
					}

					canvas.width = width;
					canvas.height = height;
					const ctx = canvas.getContext("2d");
					ctx.drawImage(img, 0, 0, width, height);

					const resized = new Image();
					resized.onload = () => resolve(resized);
					resized.src = canvas.toDataURL();
				});
			}

			function loadImage(file) {
				return new Promise((r, j) => {
					const u = URL.createObjectURL(file);
					const i = new Image();
					i.onload = () => {
						URL.revokeObjectURL(u);
						r(i);
					};
					i.onerror = j;
					i.src = u;
				});
			}
			// === Image Filters ===
			function filterBinarize(ctx, w, h, threshold) {
				const d = ctx.getImageData(0, 0, w, h);
				for (let i = 0; i < d.data.length; i += 4) {
					const gray =
						0.299 * d.data[i] +
						0.587 * d.data[i + 1] +
						0.114 * d.data[i + 2];
					const v = gray >= threshold ? 255 : 0;
					d.data[i] = d.data[i + 1] = d.data[i + 2] = v;
				}
				ctx.putImageData(d, 0, 0);
			}

			function filterAdaptiveBinarize(ctx, w, h) {
				const d = ctx.getImageData(0, 0, w, h);
				const gray = new Uint8Array(w * h);

				// è½¬ç°åº¦
				for (let i = 0; i < d.data.length; i += 4) {
					gray[i / 4] =
						0.299 * d.data[i] +
						0.587 * d.data[i + 1] +
						0.114 * d.data[i + 2];
				}

				// Otsu è‡ªåŠ¨é˜ˆå€¼
				let histogram = new Array(256).fill(0);
				for (let i = 0; i < gray.length; i++) {
					histogram[Math.floor(gray[i])]++;
				}

				let total = gray.length;
				let sum = 0;
				for (let i = 0; i < 256; i++) sum += i * histogram[i];

				let sumB = 0,
					wB = 0,
					wF = 0,
					maxVar = 0,
					threshold = 0;
				for (let t = 0; t < 256; t++) {
					wB += histogram[t];
					if (wB === 0) continue;
					wF = total - wB;
					if (wF === 0) break;

					sumB += t * histogram[t];
					let mB = sumB / wB;
					let mF = (sum - sumB) / wF;
					let varBetween = wB * wF * (mB - mF) * (mB - mF);

					if (varBetween > maxVar) {
						maxVar = varBetween;
						threshold = t;
					}
				}

				// åº”ç”¨é˜ˆå€¼
				for (let i = 0; i < d.data.length; i += 4) {
					const v = gray[i / 4] >= threshold ? 255 : 0;
					d.data[i] = d.data[i + 1] = d.data[i + 2] = v;
				}
				ctx.putImageData(d, 0, 0);
			}

			function filterSharpen(ctx, w, h) {
				const d = ctx.getImageData(0, 0, w, h);
				const original = new Uint8ClampedArray(d.data);
				const kernel = [0, -1, 0, -1, 5, -1, 0, -1, 0];

				for (let y = 1; y < h - 1; y++) {
					for (let x = 1; x < w - 1; x++) {
						for (let c = 0; c < 3; c++) {
							let sum = 0;
							for (let ky = -1; ky <= 1; ky++) {
								for (let kx = -1; kx <= 1; kx++) {
									const idx =
										((y + ky) * w + (x + kx)) * 4 + c;
									sum +=
										original[idx] *
										kernel[(ky + 1) * 3 + (kx + 1)];
								}
							}
							d.data[(y * w + x) * 4 + c] = Math.max(
								0,
								Math.min(255, sum)
							);
						}
					}
				}
				ctx.putImageData(d, 0, 0);
			}

			function filterDenoise(ctx, w, h) {
				const d = ctx.getImageData(0, 0, w, h);
				const original = new Uint8ClampedArray(d.data);

				// ç®€å•ä¸­å€¼æ»¤æ³¢
				for (let y = 1; y < h - 1; y++) {
					for (let x = 1; x < w - 1; x++) {
						for (let c = 0; c < 3; c++) {
							const values = [];
							for (let ky = -1; ky <= 1; ky++) {
								for (let kx = -1; kx <= 1; kx++) {
									values.push(
										original[
											((y + ky) * w + (x + kx)) * 4 + c
										]
									);
								}
							}
							values.sort((a, b) => a - b);
							d.data[(y * w + x) * 4 + c] = values[4]; // ä¸­å€¼
						}
					}
				}
				ctx.putImageData(d, 0, 0);
			}

			function filterHighContrast(ctx, w, h) {
				const d = ctx.getImageData(0, 0, w, h);
				const factor = 1.5;
				const intercept = 128 * (1 - factor);

				for (let i = 0; i < d.data.length; i += 4) {
					d.data[i] = Math.max(
						0,
						Math.min(255, d.data[i] * factor + intercept)
					);
					d.data[i + 1] = Math.max(
						0,
						Math.min(255, d.data[i + 1] * factor + intercept)
					);
					d.data[i + 2] = Math.max(
						0,
						Math.min(255, d.data[i + 2] * factor + intercept)
					);
				}
				ctx.putImageData(d, 0, 0);
			}

			function filterInvert(ctx, w, h) {
				const d = ctx.getImageData(0, 0, w, h);
				for (let i = 0; i < d.data.length; i += 4) {
					d.data[i] = 255 - d.data[i];
					d.data[i + 1] = 255 - d.data[i + 1];
					d.data[i + 2] = 255 - d.data[i + 2];
				}
				ctx.putImageData(d, 0, 0);
			}

			// === Core: Protobuf ===
			function parseProtobuf(urlStr) {
				if (!urlStr || typeof urlStr !== "string") {
					throw new Error("æ— æ•ˆçš„è¾“å…¥");
				}

				if (!urlStr.includes("otpauth-migration")) {
					throw new Error("ä¸æ˜¯æœ‰æ•ˆçš„ Google Authenticator è¿ç§»é“¾æ¥");
				}

				let b64 = "";
				try {
					const url = new URL(urlStr);
					b64 = url.searchParams.get("data");
				} catch {
					// å®¹é”™ï¼šæ‰‹åŠ¨è§£æ URL
					const match = urlStr.match(/[?&]data=([^&]+)/);
					b64 = match ? match[1] : null;
				}

				if (!b64) {
					throw new Error("é“¾æ¥ä¸­ç¼ºå°‘æ•°æ®å­—æ®µ");
				}

				// è§£ç  URL ç¼–ç å¹¶è½¬æ¢ Base64URL åˆ°æ ‡å‡† Base64
				b64 = decodeURIComponent(b64)
					.replace(/-/g, "+")
					.replace(/_/g, "/");

				// Base64 è§£ç ï¼ˆå…ˆå°è¯•ä¸åŠ paddingï¼Œå¤±è´¥å†åŠ ï¼‰
				let bytes;
				try {
					const bin = atob(b64);
					bytes = new Uint8Array(bin.length);
					for (let i = 0; i < bin.length; i++) {
						bytes[i] = bin.charCodeAt(i);
					}
				} catch (e) {
					// å°è¯•æ·»åŠ  padding
					try {
						let paddedB64 = b64;
						while (paddedB64.length % 4 !== 0) {
							paddedB64 += "=";
						}
						const bin = atob(paddedB64);
						bytes = new Uint8Array(bin.length);
						for (let i = 0; i < bin.length; i++) {
							bytes[i] = bin.charCodeAt(i);
						}
					} catch (e2) {
						throw new Error("Base64 è§£ç å¤±è´¥");
					}
				}

				if (bytes.length === 0) {
					throw new Error("è§£ç åæ•°æ®ä¸ºç©º");
				}

				const list = [];
				let ptr = 0;

				const readVarint = () => {
					let r = 0,
						s = 0,
						b;
					do {
						b = bytes[ptr++];
						r |= (b & 0x7f) << s;
						s += 7;
					} while (b & 0x80);
					return r;
				};

				while (ptr < bytes.length) {
					try {
						const k = readVarint();
						const f = k >> 3;
						const t = k & 7;

						if (f === 1 && t === 2) {
							// OTP å‚æ•°æ¶ˆæ¯
							const len = readVarint();
							const end = ptr + len;

							if (end > bytes.length) {
								console.warn("æ¶ˆæ¯é•¿åº¦è¶…å‡ºèŒƒå›´ï¼Œè·³è¿‡æ­¤è´¦æˆ·");
								ptr = bytes.length; // é˜²æ­¢æ­»å¾ªç¯
								break;
							}

							const item = {
								algo: "SHA1",
								digits: 6,
								type: "totp",
								period: 30,
							};

							while (ptr < end) {
								const pk = readVarint();
								const pf = pk >> 3;
								const pt = pk & 7;

								if (pt === 2) {
									// å­—ç¬¦ä¸²/å­—èŠ‚å­—æ®µ
									const pl = readVarint();
									if (ptr + pl > bytes.length) {
										console.warn("å­—æ®µé•¿åº¦è¶…å‡ºèŒƒå›´ï¼Œè·³è¿‡");
										ptr = bytes.length; // é˜²æ­¢è¶Šç•Œ
										break;
									}
									const val = bytes.slice(ptr, ptr + pl);
									ptr += pl;

									if (pf === 1) {
										// Secretå­—æ®µ - äºŒè¿›åˆ¶æ•°æ®ç›´æ¥Base32ç¼–ç 
										try {
											const alphabet =
												"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
											let bs = 0,
												v = 0,
												out = "";
											for (const b of val) {
												v = (v << 8) | b;
												bs += 8;
												while (bs >= 5) {
													out +=
														alphabet[
															(v >>> (bs - 5)) &
																31
														];
													bs -= 5;
												}
											}
											if (bs > 0) {
												out +=
													alphabet[
														(v << (5 - bs)) & 31
													];
											}
											item.secret = out;
										} catch (e) {
											console.warn("Secretç¼–ç å¤±è´¥:", e);
										}
									} else {
										// å…¶ä»–å­—æ®µ - UTF-8æ–‡æœ¬
										try {
											const txt = new TextDecoder(
												"utf-8"
											).decode(val);
											if (pf === 2) {
												item.name = txt;
											} else if (pf === 3) {
												item.issuer = txt;
											} else if (pf === 4) {
												item.algo = txt;
											}
										} catch (e) {
											console.warn(
												"æ–‡æœ¬å­—æ®µè§£ç å¤±è´¥:",
												e
											);
										}
									}
								} else if (pt === 0) {
									// Varint å­—æ®µ
									const val = readVarint();

									if (pf === 4) {
										// Algorithm
										item.algo =
											{
												1: "SHA1",
												2: "SHA256",
												3: "SHA512",
												4: "MD5",
											}[val] || "SHA1";
									} else if (pf === 5) {
										// Digits
										item.digits = val === 2 ? 8 : 6;
									} else if (pf === 6) {
										// Type
										item.type = val === 1 ? "hotp" : "totp";
									} else if (pf === 7) {
										// Counter (for HOTP)
										item.counter = val;
									}
								} else {
									// è·³è¿‡æœªçŸ¥å­—æ®µ
									if (pt === 2) {
										const skipLen = readVarint();
										ptr += skipLen;
									} else if (pt === 0) {
										readVarint();
									} else if (pt === 5) {
										ptr += 4;
									} else if (pt === 1) {
										ptr += 8;
									}
								}
							}

							// éªŒè¯å¿…éœ€å­—æ®µ
							if (item.secret && item.secret.length > 0) {
								// è®¾ç½®é»˜è®¤å€¼
								if (!item.name || item.name.trim() === "") {
									item.name = item.issuer || "æœªå‘½åè´¦æˆ·";
								}
								list.push(item);
							} else {
								console.warn("è·³è¿‡æ— æ•ˆè´¦æˆ·ï¼ˆç¼ºå°‘ secretï¼‰");
							}
						} else {
							// è·³è¿‡é¡¶çº§æœªçŸ¥å­—æ®µ
							if (t === 2) {
								const skipLen = readVarint();
								ptr += skipLen;
							} else if (t === 0) {
								readVarint();
							} else if (t === 5) {
								ptr += 4;
							} else if (t === 1) {
								ptr += 8;
							}
						}
					} catch (e) {
						// å•ä¸ªè´¦æˆ·è§£æå¤±è´¥ï¼Œè®°å½•å¹¶ç»§ç»­ä¸‹ä¸€ä¸ª
						console.warn("è·³è¿‡ä¸€ä¸ªè§£æå¤±è´¥çš„è´¦æˆ·:", e.message);
						// å°è¯•æ¢å¤åˆ°å®‰å…¨ä½ç½®ï¼Œè·³è¿‡å‰©ä½™æ•°æ®
						try {
							if (ptr < bytes.length) {
								// å°è¯•è·³è¿‡å½“å‰æŸåçš„æ¶ˆæ¯
								const skipLen = readVarint();
								if (ptr + skipLen <= bytes.length) {
									ptr += skipLen;
								}
							}
						} catch {
							// æ— æ³•æ¢å¤ï¼Œé€€å‡ºå¾ªç¯
							break;
						}
					}
				}

				if (list.length === 0) {
					throw new Error("æœªæ‰¾åˆ°æœ‰æ•ˆçš„ OTP è´¦æˆ·");
				}

				return list;
			}

			// === UI Logic ===
			function mergeAccounts(newItems) {
				const existing = new Set(state.accounts.map((a) => a.secret));
				newItems.forEach((item) => {
					if (!existing.has(item.secret)) state.accounts.push(item);
				});
				// ä¿å­˜åˆ° IndexedDB
				saveToIndexedDB(state.accounts);
			}

			function renderGrid(filter = "") {
				const div = document.getElementById("gridContainer");
				div.innerHTML = "";
				const f = filter.toLowerCase();
				const list = state.accounts
					.map((acc, i) => ({ acc, i }))
					.filter(
						(o) =>
							(o.acc.name || "").toLowerCase().includes(f) ||
							(o.acc.issuer || "").toLowerCase().includes(f)
					);

				const hasAccounts = state.accounts.length > 0;
				document
					.getElementById("statsBar")
					.classList.toggle("hidden", !hasAccounts);
				document
					.getElementById("infoBanner")
					.classList.toggle("hidden", !hasAccounts);
				document.getElementById("emptyState").style.display =
					hasAccounts ? "none" : "block";
				document.getElementById("countDisplay").textContent =
					state.accounts.length;
				document.getElementById("exportMenuBtn").disabled =
					!hasAccounts;

				list.forEach(({ acc, i }) => {
					const card = document.createElement("div");
					card.className = "card";
					card.innerHTML = `
                <div class="card-header">
                    <div class="service-icon">${getIcon(acc)}</div>
                    <div class="card-info">
                        <div class="card-title" title="${esc(acc.name)}">${esc(
						acc.name
					)}</div>
                        <div class="card-subtitle">${esc(
							acc.issuer || t("qrUnknown")
						)}</div>
                        <div class="tags"><span class="tag totp">${acc.type.toUpperCase()}</span><span class="tag">${
						acc.algo
					}</span><span class="tag">${acc.digits}${
						currentLang === "zh" ? "ä½" : " digits"
					}</span></div>
                    </div>
                </div>
                <div class="card-actions">
                    <button class="btn btn-secondary btn-sm btn-icon" onclick="showQRCode(${i})" style="flex: 1;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="3" width="7" height="7"/>
                            <rect x="14" y="3" width="7" height="7"/>
                            <rect x="3" y="14" width="7" height="7"/>
                            <rect x="14" y="14" width="7" height="7"/>
                        </svg>
                        ${t("cardQR")}
                    </button>
                    <button class="btn delete-btn btn-sm" onclick="removeAccount(${i})">${t(
						"cardDelete"
					)}</button>
                </div>
            `;
					div.appendChild(card);
				});
			}

			// === Exports ===
			function generateUri(acc) {
				const name = acc.issuer
					? `${acc.issuer}:${acc.name}`
					: acc.name;

				let uri = `otpauth://${acc.type}/${encodeURIComponent(
					name
				)}?secret=${acc.secret}`;

				if (acc.issuer) {
					uri += `&issuer=${encodeURIComponent(acc.issuer)}`;
				}

				uri += `&digits=${acc.digits}&algorithm=${acc.algo}`;

				// TOTP ä½¿ç”¨ periodï¼ŒHOTP ä½¿ç”¨ counter
				if (acc.type === "totp") {
					uri += `&period=${acc.period || 30}`;
				} else if (acc.type === "hotp" && acc.counter !== undefined) {
					uri += `&counter=${acc.counter}`;
				}

				return uri;
			}

			window.exportData = (type) => {
				let content, mime, name;
				const date = new Date().toISOString().slice(0, 10);

				if (type === "bitwarden") {
					const items = state.accounts.map((acc) => ({
						type: 1,
						name: acc.issuer
							? `${acc.issuer}: ${acc.name}`
							: acc.name,
						login: { totp: generateUri(acc) },
					}));
					content = JSON.stringify(
						{ encrypted: false, items },
						null,
						2
					);
					mime = "application/json";
					name = `bitwarden_export_${date}.json`;
				} else if (type === "csv") {
					const headers =
						"name,secret,issuer,type,algorithm,digits,period,uri\n";
					const rows = state.accounts
						.map((acc) => {
							const n = `"${(acc.name || "").replace(
								/"/g,
								'""'
							)}"`;
							const i = `"${(acc.issuer || "").replace(
								/"/g,
								'""'
							)}"`;
							return `${n},${acc.secret},${i},${acc.type},${
								acc.algo
							},${acc.digits},30,"${generateUri(acc)}"`;
						})
						.join("\n");
					content = headers + rows;
					mime = "text/csv";
					name = `otp_export_${date}.csv`;
				} else if (type === "txt") {
					content = state.accounts
						.map((acc) => generateUri(acc))
						.join("\n");
					mime = "text/plain";
					name = `otp_uris_${date}.txt`;
				}

				const blob = new Blob([content], { type: mime });
				const a = document.createElement("a");
				a.href = URL.createObjectURL(blob);
				a.download = name;
				a.click();
				closeModal("exportModal");
				showToast(t("toastExportSuccess"), "success");
			};

			// === Utils ===
			let confirmCallback = null;

			window.showConfirm = (title, message, callback) => {
				document.getElementById("confirmTitle").textContent = title;
				document.getElementById("confirmMessage").textContent = message;
				confirmCallback = callback;
				openModal("confirmModal");
			};

			window.handleConfirm = () => {
				if (confirmCallback) {
					confirmCallback();
					confirmCallback = null;
				}
				closeModal("confirmModal");
			};

			window.removeAccount = (i) => {
				showConfirm(t("confirmDelete"), t("confirmDeleteMsg"), () => {
					state.accounts.splice(i, 1);
					saveToIndexedDB(state.accounts);
					renderGrid();
					showToast(t("toastDeleteSuccess"), "success");
				});
			};

			window.confirmClearAll = () => {
				showConfirm(
					t("confirmClearAll"),
					t("confirmClearAllMsg"),
					() => {
						state.accounts = [];
						clearIndexedDB();
						renderGrid();
						showToast(t("toastClearSuccess"), "success");
					}
				);
			};
			// === QR Code Functions ===
			window.showQRCode = (index) => {
				const acc = state.accounts[index];
				const uri = generateUri(acc);

				try {
					// ä½¿ç”¨ qrcode-generator åº“
					const qr = qrcode(0, "H"); // 0 = auto-detect, 'H' = high error correction
					qr.addData(uri);
					qr.make();

					// åˆ›å»º canvas å¹¶ç»˜åˆ¶
					const canvas = document.getElementById("qrCanvas");
					const cellSize = 7; // æ¯ä¸ªå•å…ƒæ ¼çš„åƒç´ å¤§å°
					const margin = 2; // è¾¹è·ï¼ˆå•å…ƒæ ¼æ•°é‡ï¼‰
					const size = qr.getModuleCount();
					const totalSize = (size + margin * 2) * cellSize;

					canvas.width = totalSize;
					canvas.height = totalSize;
					const ctx = canvas.getContext("2d");

					// ç™½è‰²èƒŒæ™¯
					ctx.fillStyle = "#FFFFFF";
					ctx.fillRect(0, 0, totalSize, totalSize);

					// ç»˜åˆ¶äºŒç»´ç 
					ctx.fillStyle = "#000000";
					for (let row = 0; row < size; row++) {
						for (let col = 0; col < size; col++) {
							if (qr.isDark(row, col)) {
								ctx.fillRect(
									(col + margin) * cellSize,
									(row + margin) * cellSize,
									cellSize,
									cellSize
								);
							}
						}
					}

					// è®¾ç½®æ ‡é¢˜å’Œä¿¡æ¯
					document.getElementById("qrModalTitle").textContent =
						acc.name || "äºŒç»´ç ";
					document.getElementById("qrInfo").innerHTML = `
						<div class="qr-info-row">
							<span class="qr-info-label">${t("qrAccount")}</span>
							<span class="qr-info-value">${esc(acc.name)}</span>
						</div>
						<div class="qr-info-row">
							<span class="qr-info-label">${t("qrIssuer")}</span>
							<span class="qr-info-value">${esc(acc.issuer || "æœªçŸ¥")}</span>
						</div>
						<div class="qr-info-row">
							<span class="qr-info-label">${t("qrType")}</span>
							<span class="qr-info-value">${acc.type.toUpperCase()}</span>
						</div>
						<div class="qr-info-row">
							<span class="qr-info-label">${t("qrAlgo")}</span>
							<span class="qr-info-value">${acc.algo} / ${acc.digits}ä½</span>
						</div>
					`;

					openModal("qrModal");
				} catch (error) {
					showToast(t("errorQRGeneration"), "error");
					console.error(error);
				}
			};

			window.exportQRCodes = async () => {
				if (state.accounts.length === 0) {
					showToast(t("toastNoExport"), "error");
					return;
				}

				closeModal("exportModal");
				openModal("progressModal");

				try {
					const zip = new JSZip();
					const total = state.accounts.length;

					for (let i = 0; i < total; i++) {
						const acc = state.accounts[i];
						updateProgress(i + 1, total, `ç”ŸæˆäºŒç»´ç : ${acc.name}`);

						const uri = generateUri(acc);

						// ä½¿ç”¨ qrcode-generator ç”Ÿæˆé«˜åˆ†è¾¨ç‡äºŒç»´ç 
						const qr = qrcode(0, "H");
						qr.addData(uri);
						qr.make();

						// åˆ›å»ºé«˜åˆ†è¾¨ç‡ canvas
						const canvas = document.createElement("canvas");
						const cellSize = 10; // æ›´å¤§çš„å•å…ƒæ ¼ç”¨äºé«˜åˆ†è¾¨ç‡
						const margin = 4;
						const size = qr.getModuleCount();
						const totalSize = (size + margin * 2) * cellSize;

						canvas.width = totalSize;
						canvas.height = totalSize;
						const ctx = canvas.getContext("2d");

						// ç™½è‰²èƒŒæ™¯
						ctx.fillStyle = "#FFFFFF";
						ctx.fillRect(0, 0, totalSize, totalSize);

						// ç»˜åˆ¶äºŒç»´ç 
						ctx.fillStyle = "#000000";
						for (let row = 0; row < size; row++) {
							for (let col = 0; col < size; col++) {
								if (qr.isDark(row, col)) {
									ctx.fillRect(
										(col + margin) * cellSize,
										(row + margin) * cellSize,
										cellSize,
										cellSize
									);
								}
							}
						}

						// è½¬æ¢ä¸ºPNG
						const blob = await new Promise((resolve) =>
							canvas.toBlob(resolve, "image/png")
						);

						// åˆ›å»ºå®‰å…¨çš„æ–‡ä»¶å
						const safeName = (
							acc.issuer ? `${acc.issuer}_${acc.name}` : acc.name
						)
							.replace(/[<>:"/\\|?*]/g, "_")
							.substring(0, 100);

						zip.file(`${safeName}.png`, blob);

						await new Promise((r) => setTimeout(r, 50));
					}

					updateProgress(total, total, "æ­£åœ¨å‹ç¼©...");
					const zipBlob = await zip.generateAsync({ type: "blob" });

					const date = new Date().toISOString().slice(0, 10);
					const a = document.createElement("a");
					a.href = URL.createObjectURL(zipBlob);
					a.download = `qrcodes_${date}.zip`;
					a.click();

					setTimeout(() => {
						closeModal("progressModal");
						showToast(
							t("toastQRExportSuccess", { count: total }),
							"success"
						);
					}, 500);
				} catch (error) {
					closeModal("progressModal");
					showToast(t("errorExportFailed"), "error");
					console.error(error);
				}
			};

			window.openModal = (id) =>
				document.getElementById(id).classList.add("show");
			window.closeModal = (id) =>
				document.getElementById(id).classList.remove("show");
			window.processManual = () => {
				const input = document.getElementById("manualInput");
				const v = input.value.trim();

				if (!v) {
					showToast(t("toastInvalidInput"), "error");
					return;
				}

				try {
					const accounts = parseProtobuf(v);
					if (accounts && accounts.length > 0) {
						mergeAccounts(accounts);
						renderGrid();
						closeModal("manualModal");
						input.value = "";
						showToast(
							t("toastParseSuccess", { count: accounts.length }),
							"success"
						);
					} else {
						showToast(t("toastNoAccounts"), "error");
					}
				} catch (e) {
					console.error("æ‰‹åŠ¨è§£æå¤±è´¥:", e);
					let errorMsg = "è§£æå¤±è´¥";

					if (e.message.includes("è¿ç§»é“¾æ¥")) {
						errorMsg = "è¯·è¾“å…¥æœ‰æ•ˆçš„ Google Authenticator è¿ç§»é“¾æ¥";
					} else if (e.message.includes("æ•°æ®å­—æ®µ")) {
						errorMsg = "é“¾æ¥æ ¼å¼é”™è¯¯ï¼šç¼ºå°‘æ•°æ®éƒ¨åˆ†";
					} else if (e.message.includes("Base64")) {
						errorMsg = "æ•°æ®æ ¼å¼é”™è¯¯ï¼šæ— æ³•è§£ç ";
					} else if (e.message.includes("Protobuf")) {
						errorMsg = "æ•°æ®æŸåï¼š" + e.message;
					} else {
						errorMsg = e.message;
					}

					showToast(errorMsg, "error");
				}
			};
			function updateProgress(i, t, msg) {
				document.getElementById("progressFill").style.width =
					Math.round((i / t) * 100) + "%";
				document.getElementById(
					"progressText"
				).textContent = `å¤„ç†ä¸­ ${i}/${t}: ${msg}`;
			}
			function showToast(msg, type) {
				const t = document.createElement("div");
				t.className = `toast ${type}`;
				t.textContent = msg;
				document.getElementById("toastContainer").appendChild(t);
				setTimeout(() => t.remove(), 3000);
			}
			function getIcon(acc) {
				const k = (acc.issuer + acc.name).toLowerCase();
				if (k.includes("git")) return ICONS.github;
				if (k.includes("goog")) return ICONS.google;
				if (k.includes("aws")) return ICONS.aws;
				return ICONS.default;
			}
			function esc(s) {
				return s ? s.replace(/&/g, "&amp;").replace(/</g, "&lt;") : "";
			}

			// === Page Initialization ===
			async function init() {
				// æ£€æµ‹å¹¶è®¾ç½®è¯­è¨€
				currentLang = detectLanguage();
				updateUILanguage();

				try {
					// åˆå§‹åŒ– IndexedDB
					await initDB();

					// å°è¯•ä» IndexedDB æ¢å¤æ•°æ®
					const savedAccounts = await loadFromIndexedDB();
					if (savedAccounts && savedAccounts.length > 0) {
						state.accounts = savedAccounts;
						renderGrid();
						showToast(
							t("toastRecovered", {
								count: savedAccounts.length,
							}),
							"success"
						);
					}

					// æ·»åŠ æ¨¡æ€æ¡†ç‚¹å‡»å¤–éƒ¨å…³é—­åŠŸèƒ½
					const modals = ["exportModal", "manualModal", "qrModal"];
					modals.forEach((modalId) => {
						const overlay = document.getElementById(modalId);
						if (overlay) {
							overlay.addEventListener("click", (e) => {
								if (e.target === overlay) {
									closeModal(modalId);
								}
							});
						}
					});
				} catch (error) {
					console.error("åˆå§‹åŒ–å¤±è´¥:", error);
				}
			}

			// é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
			if (document.readyState === "loading") {
				document.addEventListener("DOMContentLoaded", init);
			} else {
				init();
			}
		</script>
	</body>
</html>
